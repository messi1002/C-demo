/*
1-6 最大子列和问题 （20 分）

“最大子列和”则被定义为所有连续子列元素的和中最大者。
例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。
现要求你编写程序，计算给定整数序列的最大子列和。

输入格式:
输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。

输出格式:
在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。

输入样例:
6
-2 11 -4 13 -5 -2

输出样例:
20
*/

#include <stdio.h>

int main()
{
  int n;
  scanf("%d", &n);
  int a[n], i;
  int length = sizeof(a) / sizeof(a[0]);
  int maxSum = 0, thisSum = 0;
  
  // 读入数据。 
  for (i = 0; i < length; i++)
  {
    scanf("%d", &a[i]);
  }
  
  // 在线处理方法,任何时候停止程序,输出的最大子列和都是正确的。 
  /*
  2 -3 6 -1 5 -9 2 3 4 8
  假如输入这些数,过程如下。 
  i  thisSum maxSum  
  0  2       2
  1  0(-1)   2
  2  6       6
  3  5       6
  4  10      10
  5  1       10
  6  3       10
  7  6       10
  8  10      10
  9  18      18     
  可以看出maxSum用于保存曾经的子串最大值,thisSum保存现阶段子串的增加。
  一旦发现有新子串大于曾经的子串,替换之。
  与最基础的需要比较所有子串的算法相比,这个算法的优势在于动态管理和删选。 
  */
  for (i = 0; i < length; i++)
  {
	thisSum = thisSum + a[i]; 
  
  	if (maxSum < thisSum)
  	{
  		maxSum = thisSum;
	}

	// 这里是重点,不可能使后面的和增大,抛弃之。 
	if (thisSum < 0)
	{
		thisSum = 0;
	}
  }

  printf("%d\n", maxSum);
  
  return 0;
}
